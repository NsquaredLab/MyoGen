
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>myogen.simulator.core.emg.surface_emg &#8212; MyoGen 0.1.0 Documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../../../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/custom.css?v=e1466590" />
  
  <!-- So that users can add custom icons -->
  <script src="../../../../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../../../../_static/documentation_options.js?v=01f34227"></script>
    <script src="../../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/myogen/simulator/core/emg/surface_emg';</script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="0.1.0" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class=" navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../../../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../../../../_static/myogen_logo.png" class="logo__image only-light" alt="MyoGen 0.1.0 Documentation - Home"/>
    <img src="../../../../../_static/myogen_logo.png" class="logo__image only-dark pst-js-only" alt="MyoGen 0.1.0 Documentation - Home"/>
  
  
</a></div>
    
      <div class="navbar-item">
<div class="nav-item">
  <div class="version-switcher__container dropdown">
      <button id="version-switcher-button" type="button" class="version-switcher__button btn btn-sm navbar-btn" aria-haspopup="true" aria-expanded="false">
          Version 0.1.0
      </button>
      
      
      
  </div>
</div> </div>
    
      <div class="navbar-item"><div class="nav-item">
   <span>
      made at the <a href="https://www.nsquared.tf.fau.de/" target="_blank">N² Lab</a>
   </span>
</div> </div>
    
  </div>
  
  <div class=" navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../../api/index.html">
    API Documentation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../../auto_examples/index.html">
    Examples
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NSquaredLab/MyoGen" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../../api/index.html">
    API Documentation
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../../../../auto_examples/index.html">
    Examples
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/NSquaredLab/MyoGen" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../../../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../../../../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">myogen.simulator.core.emg.surface_emg</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for myogen.simulator.core.emg.surface_emg</h1><div class="highlight"><pre>
<span></span><span class="c1">#######################################################################################################</span>
<span class="c1">##################################### Initial Explanations ############################################</span>
<span class="c1">#######################################################################################################</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Surface EMG Simulation for First Dorsal Interosseous (FDI) Muscle</span>
<span class="sd">================================================================</span>

<span class="sd">This module provides simulation capabilities for surface electromyography (sEMG)</span>
<span class="sd">signals from the First Dorsal Interosseous (FDI) muscle. It implements a comprehensive</span>
<span class="sd">volume conductor model that accounts for realistic anatomical and physiological parameters.</span>

<span class="sd">Scientific Background</span>
<span class="sd">--------------------</span>
<span class="sd">The simulation is based on well-established biophysical principles:</span>

<span class="sd">1. **Volume Conductor Theory**: Models the human body as a multi-layered cylindrical volume</span>
<span class="sd">   conductor with different tissue conductivities (muscle, fat, skin).</span>

<span class="sd">2. **Motor Unit Action Potentials (MUAPs)**: Each motor unit generates characteristic</span>
<span class="sd">   electrical signals that can be detected at the skin surface through multi-electrode arrays.</span>

<span class="sd">3. **Anatomical Modeling**: Incorporates realistic FDI muscle geometry, fiber distribution,</span>
<span class="sd">   and motor unit territories based on anatomical studies.</span>

<span class="sd">Key Features</span>
<span class="sd">-----------</span>
<span class="sd">- Multi-position electrode array simulation for comprehensive spatial sampling</span>
<span class="sd">- Realistic tissue conductivity modeling (anisotropic muscle, fat, skin layers)</span>
<span class="sd">- Optimized computation through matrix reuse across electrode positions</span>
<span class="sd">- Comprehensive parameter validation and error handling</span>
<span class="sd">- Support for partial motor unit simulation for computational efficiency</span>

<span class="sd">Mathematical Model</span>
<span class="sd">------------------</span>
<span class="sd">The simulation implements the forward problem of EMG, computing surface potentials φ(r,t)</span>
<span class="sd">as a function of:</span>
<span class="sd">- Intracellular action potential propagation along muscle fibers</span>
<span class="sd">- Volume conductor properties (conductivity tensors)</span>
<span class="sd">- Electrode-tissue interface characteristics</span>
<span class="sd">- Spatial distribution of motor units and muscle fibers</span>

<span class="sd">Usage Examples</span>
<span class="sd">--------------</span>
<span class="sd">```python</span>
<span class="sd"># Single electrode position</span>
<span class="sd">muaps_single = simulate_muaps(</span>
<span class="sd">    muscle_model=muscle,</span>
<span class="sd">    MUs_to_simulate=[0, 1, 2],</span>
<span class="sd">    electrode_grid_dimensions__rows_cols=(8, 8),</span>
<span class="sd">    electrode_grid_center_positions=[None]  # Default anatomical center</span>
<span class="sd">)</span>

<span class="sd"># Multiple electrode positions for spatial analysis</span>
<span class="sd">muaps_multi = simulate_muaps(</span>
<span class="sd">    muscle_model=muscle,</span>
<span class="sd">    MUs_to_simulate=list(range(10)),</span>
<span class="sd">    electrode_grid_center_positions=[</span>
<span class="sd">        (0, 0),                    # Center</span>
<span class="sd">        (5, numpy.deg2rad(45)),   # 45° offset</span>
<span class="sd">        (5, numpy.deg2rad(90)),   # 90° offset</span>
<span class="sd">    ]</span>
<span class="sd">)</span>
<span class="sd">```</span>

<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">This implementation is based on peer-reviewed research in computational EMG modeling,</span>
<span class="sd">particularly the work by Botelho et al. (2019) on anatomically accurate EMG models</span>
<span class="sd">derived from diffusion tensor imaging.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># This script simulates the FDI muscle: it simulates the script simulate_fiber.py several times and generates</span>
<span class="c1"># the MUAPs for each MU dectected at each electrode channel. It calls the script Distribute_circles.py to</span>
<span class="c1"># distributes the motor units inside the muscle and the fibers inside each motor unit.</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">cupy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>

    <span class="n">HAS_CUPY</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">HAS_CUPY</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">joblib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.patches</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">patches</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">beartype</span><span class="w"> </span><span class="kn">import</span> <span class="n">beartype</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">resample</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">myogen</span><span class="w"> </span><span class="kn">import</span> <span class="n">RANDOM_GENERATOR</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">myogen.simulator.core.muscle</span><span class="w"> </span><span class="kn">import</span> <span class="n">Muscle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">myogen.simulator.core.spike_train</span><span class="w"> </span><span class="kn">import</span> <span class="n">MotorNeuronPool</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">myogen.simulator.core.emg.simulate_fiber</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">simulate_fiber</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">myogen.utils.types</span><span class="w"> </span><span class="kn">import</span> <span class="n">MUAP_SHAPE__TENSOR</span>

<span class="c1"># Suppress warnings for cleaner output during batch simulations</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="SurfaceEMG">
<a class="viewcode-back" href="../../../../../generated/myogen.simulator.SurfaceEMG.html#myogen.simulator.SurfaceEMG">[docs]</a>
<span class="nd">@beartype</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SurfaceEMG</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Surface Electromyography (sEMG) Simulation.</span>
<span class="sd">    </span>
<span class="sd">    This class provides a biophysical simulation framework for generating</span>
<span class="sd">    surface electromyography signals from the muscle. It implements a</span>
<span class="sd">    multi-layered cylindrical volume conductor model that accounts for</span>
<span class="sd">    anatomical accuracy, physiological variability, and measurement noise</span>
<span class="sd">    characteristics typical of clinical and research EMG recordings.</span>
<span class="sd">    </span>
<span class="sd">    The simulation is built on established biophysical principles and validated</span>
<span class="sd">    anatomical data, making it suitable for algorithm development, method validation,</span>
<span class="sd">    and educational purposes in EMG signal processing and motor control research.</span>
<span class="sd">    </span>
<span class="sd">    Scientific Foundation</span>
<span class="sd">    ---------------------</span>
<span class="sd">    The simulation framework is based on:</span>
<span class="sd">    </span>
<span class="sd">    1. **Volume Conductor Theory**: Multi-layered cylindrical model representing muscle, fat,</span>
<span class="sd">       and skin tissues with anisotropic conductivity properties.</span>
<span class="sd">    </span>
<span class="sd">    2. **Motor Unit Physiology**: Realistic motor unit territories, fiber distributions, and</span>
<span class="sd">       action potential propagation based on anatomical and physiological measurements.</span>
<span class="sd">    </span>
<span class="sd">    3. **Electrode Array Modeling**: High-density surface electrode grids with configurable</span>
<span class="sd">       spatial arrangements and electrode properties.</span>
<span class="sd">    </span>
<span class="sd">    4. **Signal Processing Pipeline**: Complete workflow from single-fiber action potentials</span>
<span class="sd">       to composite surface EMG signals with noise characteristics.</span>
<span class="sd">    </span>
<span class="sd">    Key Capabilities</span>
<span class="sd">    ---------------</span>
<span class="sd">    - **Multi-Position Electrode Arrays**: Simulate EMG at multiple spatial locations</span>
<span class="sd">    - **Motor Unit Action Potentials (MUAPs)**: Generate individual MUAP templates</span>
<span class="sd">    - **Composite Surface EMG**: Convolve MUAPs with spike trains for realistic EMG</span>
<span class="sd">    - **Noise Modeling**: Add measurement noise with specified signal-to-noise ratios</span>
<span class="sd">    - **Computational Optimization**: Efficient matrix reuse for large-scale simulations</span>
<span class="sd">    - **Visualization Support**: Built-in plotting capabilities for model validation</span>
<span class="sd">    </span>
<span class="sd">    Typical Workflow</span>
<span class="sd">    ---------------</span>
<span class="sd">    1. Create muscle model using `myogen.simulator.Muscle`</span>
<span class="sd">    2. Initialize `SurfaceEMG` with desired parameters</span>
<span class="sd">    3. Generate MUAP templates using `simulate_muaps()`</span>
<span class="sd">    4. Create motor neuron pool using `myogen.simulator.MotorNeuronPool`</span>
<span class="sd">    5. Generate surface EMG using `simulate_surface_emg()`</span>
<span class="sd">    6. Optionally add noise using `add_noise()`</span>
<span class="sd">    </span>
<span class="sd">    Performance Considerations</span>
<span class="sd">    -------------------------</span>
<span class="sd">    - Memory usage scales as: n_positions × n_motor_units × grid_area × time_samples</span>
<span class="sd">    - Computational cost increases with: fiber count, electrode density, temporal resolution</span>
<span class="sd">    - For large simulations (&gt;50 MUs, &gt;64 electrodes), consider parameter optimization</span>
<span class="sd">    - GPU acceleration used automatically for convolution operations in surface EMG generation</span>
<span class="sd">    </span>
<span class="sd">    Validation and Quality Assurance</span>
<span class="sd">    --------------------------------</span>
<span class="sd">    - Parameters based on peer-reviewed anatomical and physiological studies</span>
<span class="sd">    - Built-in validation checks for parameter consistency</span>
<span class="sd">    - Extensive documentation with literature references</span>
<span class="sd">    - Type checking enforced via beartype decorators</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    **Basic Usage:**</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; # Create muscle model</span>
<span class="sd">    &gt;&gt;&gt; muscle = myogen.simulator.Muscle(...)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; # Initialize surface EMG simulator</span>
<span class="sd">    &gt;&gt;&gt; surface_emg = SurfaceEMG(</span>
<span class="sd">    ...     muscle_model=muscle,</span>
<span class="sd">    ...     electrode_grid_dimensions__rows_cols=(8, 8),</span>
<span class="sd">    ...     MUs_to_simulate=[0, 1, 2, 3, 4]  # First 5 motor units</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; # Generate MUAP templates</span>
<span class="sd">    &gt;&gt;&gt; muaps = surface_emg.simulate_muaps(verbose=True)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; # Create motor neuron pool and generate surface EMG</span>
<span class="sd">    &gt;&gt;&gt; motor_pool = myogen.simulator.MotorNeuronPool(...)</span>
<span class="sd">    &gt;&gt;&gt; surface_emg_signals = surface_emg.simulate_surface_emg(motor_pool)</span>
<span class="sd">    &gt;&gt;&gt; </span>
<span class="sd">    &gt;&gt;&gt; # Add measurement noise</span>
<span class="sd">    &gt;&gt;&gt; noisy_emg = surface_emg.add_noise(snr_db=15)</span>
<span class="sd">    </span>
<span class="sd">    **Multi-Position Analysis:**</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; positions = [</span>
<span class="sd">    ...     (0, 0),                    # Center</span>
<span class="sd">    ...     (-5, np.deg2rad(45)),     # 5mm proximal, 45° rotation</span>
<span class="sd">    ...     (5, np.deg2rad(90)),      # 5mm distal, 90° rotation</span>
<span class="sd">    ... ]</span>
<span class="sd">    &gt;&gt;&gt; surface_emg = SurfaceEMG(</span>
<span class="sd">    ...     muscle_model=muscle,</span>
<span class="sd">    ...     electrode_grid_center_positions=positions,</span>
<span class="sd">    ...     MUs_to_simulate=list(range(20))  # First 20 MUs</span>
<span class="sd">    ... )</span>
<span class="sd">    &gt;&gt;&gt; muaps = surface_emg.simulate_muaps()</span>
<span class="sd">    &gt;&gt;&gt; print(f&quot;Multi-position MUAPs shape: {muaps.shape}&quot;)  # (3, 20, 8, 8, 256)</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    myogen.simulator.Muscle : For creating anatomically accurate muscle models</span>
<span class="sd">    myogen.simulator.MotorNeuronPool : For generating motor neuron spike trains</span>
<span class="sd">    myogen.utils.plotting.surface_emg : For visualizing simulation results</span>
<span class="sd">    </span>
<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Botelho, D., Curran, K., &amp; Lowery, M. M. (2019). Anatomically accurate model of </span>
<span class="sd">           EMG during index finger flexion and abduction derived from diffusion tensor imaging. </span>
<span class="sd">           PLOS Computational Biology, 15(8), e1007267.</span>
<span class="sd">    .. [2] Jacobson, M. D., et al. (1992). Architectural design of the human intrinsic hand muscles. </span>
<span class="sd">           The Journal of Hand Surgery, 17(5), 804-809.</span>
<span class="sd">    .. [3] Störchle, P., et al. (2018). Measurement of mean subcutaneous fat thickness. </span>
<span class="sd">           Scientific Reports, 8(1), 16268.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="SurfaceEMG.__init__">
<a class="viewcode-back" href="../../../../../generated/myogen.simulator.SurfaceEMG.html#myogen.simulator.SurfaceEMG.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">muscle_model</span><span class="p">:</span> <span class="n">Muscle</span><span class="p">,</span>  <span class="c1"># Resolution parameters</span>
        <span class="n">sampling_frequency__Hz</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2048.0</span><span class="p">,</span>
        <span class="n">mean_conduction_velocity__mm_s</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">4.1</span><span class="p">,</span>  <span class="c1"># Mean conduction velocity (mm/s) -&gt; (Botelho, 2019)</span>
        <span class="n">sampling_points_in_t_and_z_domains</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">256</span><span class="p">,</span>  <span class="c1"># Number of points in t and z domains (arbitrary)</span>
        <span class="n">sampling_points_in_theta_domain</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">180</span><span class="p">,</span>  <span class="c1"># Number of points in theta domain (arbitrary)</span>
        <span class="c1"># Muscle parameters (FDI)</span>
        <span class="n">MUs_to_simulate</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
        <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># List of motor unit indices to simulate</span>
        <span class="n">mean_fiber_length__mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>  <span class="c1"># Mean fiber length -&gt; (Jacobson, 1992)</span>
        <span class="n">var_fiber_length__mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1"># Fiber length variation (+ or -) -&gt; (Jacobson, 1992)</span>
        <span class="n">radius_bone__mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">fat_thickness__mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># (Storchle, 2018)</span>
        <span class="n">skin_thickness__mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># (Brodar, 1960)</span>
        <span class="c1"># Conductivities -&gt; (Botelho, 2019)</span>
        <span class="n">muscle_conductivity_radial__S_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.09</span><span class="p">,</span>
        <span class="n">muscle_conductivity_longitudinal__S_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
        <span class="n">fat_conductivity__S_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.041</span><span class="p">,</span>
        <span class="n">skin_conductivity__S_m</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># (Roeleveld, 1997)</span>
        <span class="c1"># Electrode Grid parameters</span>
        <span class="n">electrode_grid_inclination_angle__deg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">electrode_grid_dimensions__rows_cols</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
        <span class="n">inter_electrode_distance__mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">electrode_radius__mm</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.75</span><span class="p">,</span>
        <span class="n">electrode_grid_center_positions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">]</span>
        <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the Surface EMG simulator with anatomical, physiological, and technical parameters.</span>
<span class="sd">        </span>
<span class="sd">        This constructor sets up all parameters required for realistic surface EMG simulation,</span>
<span class="sd">        including muscle geometry, tissue properties, electrode configuration, and simulation</span>
<span class="sd">        resolution. All parameters are based on published anatomical and physiological studies</span>
<span class="sd">        to ensure biological realism.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        muscle_model : Muscle</span>
<span class="sd">            Pre-computed muscle model containing motor unit territories, fiber distributions,</span>
<span class="sd">            and recruitment patterns. Must be created using myogen.simulator.Muscle class.</span>
<span class="sd">            The muscle model defines the spatial organization of motor units and their</span>
<span class="sd">            associated muscle fibers within the FDI muscle volume.</span>
<span class="sd">        </span>
<span class="sd">        sampling_frequency__Hz : float, default=2048.0</span>
<span class="sd">            Temporal sampling frequency for MUAP and EMG signals in Hertz.</span>
<span class="sd">            Higher frequencies provide better temporal resolution but increase computational</span>
<span class="sd">            cost and memory usage. Typical range: 1024-4096 Hz.</span>
<span class="sd">            - Clinical EMG: 1024-2048 Hz</span>
<span class="sd">            - Research applications: 2048-4096 Hz</span>
<span class="sd">            - High-resolution studies: &gt;4096 Hz</span>
<span class="sd">        </span>
<span class="sd">        mean_conduction_velocity__mm_s : float, default=4.1</span>
<span class="sd">            Mean conduction velocity of action potentials along muscle fibers in mm/s.</span>
<span class="sd">            Based on experimental measurements from Botelho et al. (2019).</span>
<span class="sd">            This parameter significantly affects MUAP duration and propagation patterns.</span>
<span class="sd">            Typical range for FDI muscle: 3.5-4.5 mm/s.</span>
<span class="sd">        </span>
<span class="sd">        sampling_points_in_t_and_z_domains : int, default=256</span>
<span class="sd">            Spatial and temporal discretization resolution for numerical integration.</span>
<span class="sd">            Controls the accuracy of the volume conductor calculations but significantly</span>
<span class="sd">            impacts computational cost (scales quadratically). Higher values provide</span>
<span class="sd">            better numerical accuracy at the expense of simulation time.</span>
<span class="sd">            - Fast simulations: 128-256 points</span>
<span class="sd">            - Standard accuracy: 256-512 points  </span>
<span class="sd">            - High accuracy: 512-1024 points</span>
<span class="sd">        </span>
<span class="sd">        sampling_points_in_theta_domain : int, default=180</span>
<span class="sd">            Angular discretization for cylindrical coordinate system in degrees.</span>
<span class="sd">            180 points provides 2° angular resolution, which is sufficient for most</span>
<span class="sd">            surface EMG applications. Higher values provide better spatial resolution</span>
<span class="sd">            for circumferential electrode placement studies.</span>
<span class="sd">        </span>
<span class="sd">        MUs_to_simulate : list[int] or None, default=None</span>
<span class="sd">            Indices of specific motor units to simulate. If None, simulates all motor</span>
<span class="sd">            units present in the muscle model. For computational efficiency, consider</span>
<span class="sd">            simulating subsets for initial analysis or algorithm development.</span>
<span class="sd">            Motor unit indices correspond to recruitment order (0 = first recruited).</span>
<span class="sd">        </span>
<span class="sd">        mean_fiber_length__mm : float, default=32</span>
<span class="sd">            Mean muscle fiber length in millimeters based on anatomical measurements</span>
<span class="sd">            (Jacobson et al., 1992). This parameter affects MUAP duration and amplitude</span>
<span class="sd">            characteristics. Longer fibers produce longer-duration MUAPs with potentially</span>
<span class="sd">            higher amplitudes. Typical range for FDI: 28-36 mm.</span>
<span class="sd">        </span>
<span class="sd">        var_fiber_length__mm : float, default=3</span>
<span class="sd">            Standard deviation of fiber length distribution in millimeters.</span>
<span class="sd">            Introduces realistic biological variability in MUAP shapes within motor units.</span>
<span class="sd">            Higher values increase MUAP shape variability but maintain physiological realism.</span>
<span class="sd">            Typical range: 2-5 mm.</span>
<span class="sd">        </span>
<span class="sd">        radius_bone__mm : float, default=0</span>
<span class="sd">            Inner bone radius for cylindrical volume conductor model in millimeters.</span>
<span class="sd">            For surface EMG applications, bone effects are typically minimal, so default</span>
<span class="sd">            value of 0 is appropriate. Non-zero values may be used for intramuscular EMG</span>
<span class="sd">            or detailed anatomical studies.</span>
<span class="sd">        </span>
<span class="sd">        fat_thickness__mm : float, default=1</span>
<span class="sd">            Subcutaneous fat layer thickness in millimeters. This parameter significantly</span>
<span class="sd">            affects MUAP amplitude and spatial distribution due to fat&#39;s low electrical</span>
<span class="sd">            conductivity acting as an insulator. Based on ultrasound measurements</span>
<span class="sd">            (Störchle et al., 2018). Typical range: 0.5-3 mm for hand muscles.</span>
<span class="sd">        </span>
<span class="sd">        skin_thickness__mm : float, default=1</span>
<span class="sd">            Skin layer thickness in millimeters. Generally less critical than fat thickness</span>
<span class="sd">            but affects high-frequency components of MUAPs and electrode-tissue coupling.</span>
<span class="sd">            Based on histological measurements (Brodar, 1960). Typical range: 0.5-2 mm.</span>
<span class="sd">        </span>
<span class="sd">        muscle_conductivity_radial__S_m : float, default=0.09</span>
<span class="sd">            Muscle tissue electrical conductivity in radial direction (perpendicular to fibers)</span>
<span class="sd">            in Siemens per meter. Muscle tissue exhibits anisotropic conductivity due to</span>
<span class="sd">            fiber orientation, with lower conductivity perpendicular to fibers.</span>
<span class="sd">            Value based on Botelho et al. (2019).</span>
<span class="sd">        </span>
<span class="sd">        muscle_conductivity_longitudinal__S_m : float, default=0.4</span>
<span class="sd">            Muscle tissue electrical conductivity in longitudinal direction (parallel to fibers)</span>
<span class="sd">            in Siemens per meter. Approximately 4-5x higher than radial conductivity due to</span>
<span class="sd">            fiber structure and orientation. This anisotropy significantly affects MUAP</span>
<span class="sd">            spatial patterns and propagation characteristics.</span>
<span class="sd">        </span>
<span class="sd">        fat_conductivity__S_m : float, default=0.041</span>
<span class="sd">            Subcutaneous fat tissue electrical conductivity in Siemens per meter.</span>
<span class="sd">            Low conductivity makes fat act as an electrical insulator, spatially smoothing</span>
<span class="sd">            MUAP patterns and reducing amplitudes. Based on experimental measurements</span>
<span class="sd">            from tissue impedance studies.</span>
<span class="sd">        </span>
<span class="sd">        skin_conductivity__S_m : float, default=1</span>
<span class="sd">            Skin tissue electrical conductivity in Siemens per meter.</span>
<span class="sd">            Relatively high conductivity provides good electrical coupling between</span>
<span class="sd">            underlying tissues and surface electrodes. Value based on Roeleveld et al. (1997).</span>
<span class="sd">        </span>
<span class="sd">        electrode_grid_inclination_angle__deg : float, default=0</span>
<span class="sd">            Rotation angle of electrode grid relative to muscle fiber direction in degrees.</span>
<span class="sd">            - 0° = electrodes aligned parallel to muscle fibers</span>
<span class="sd">            - 90° = electrodes aligned perpendicular to muscle fibers</span>
<span class="sd">            This parameter affects MUAP propagation patterns and is important for</span>
<span class="sd">            studies of fiber direction estimation and conduction velocity analysis.</span>
<span class="sd">        </span>
<span class="sd">        electrode_grid_dimensions__rows_cols : tuple[int, int], default=(8, 8)</span>
<span class="sd">            Number of electrode rows and columns in the recording grid.</span>
<span class="sd">            Total number of electrodes = rows × columns. Common configurations:</span>
<span class="sd">            - (8, 8): 64 electrodes - standard high-density EMG</span>
<span class="sd">            - (16, 8): 128 electrodes - very high spatial resolution</span>
<span class="sd">            - (13, 5): 65 electrodes - clinical electrode arrays</span>
<span class="sd">            Higher densities provide better spatial resolution but increase data volume.</span>
<span class="sd">        </span>
<span class="sd">        inter_electrode_distance__mm : float, default=4</span>
<span class="sd">            Distance between adjacent electrodes in millimeters.</span>
<span class="sd">            Affects spatial resolution and signal crosstalk between channels.</span>
<span class="sd">            Smaller distances provide higher spatial resolution but may increase</span>
<span class="sd">            correlated noise between adjacent channels.</span>
<span class="sd">            - High resolution: 2-3 mm</span>
<span class="sd">            - Standard: 4-5 mm  </span>
<span class="sd">            - Low resolution: 8-10 mm</span>
<span class="sd">        </span>
<span class="sd">        electrode_radius__mm : float, default=0.75</span>
<span class="sd">            Physical radius of individual circular electrodes in millimeters.</span>
<span class="sd">            Affects spatial averaging (larger electrodes average over more tissue volume)</span>
<span class="sd">            and signal-to-noise ratio (larger electrodes typically have lower impedance).</span>
<span class="sd">            Standard clinical surface electrodes: 0.5-2 mm radius.</span>
<span class="sd">        </span>
<span class="sd">        electrode_grid_center_positions : list[tuple[float|int, float|int]] or None, default=None</span>
<span class="sd">            List of electrode grid center positions in cylindrical coordinates.</span>
<span class="sd">            Each position is specified as (z_position_mm, angle_radians) where:</span>
<span class="sd">            - z_position_mm: position along muscle fiber direction (+ = distal, - = proximal)</span>
<span class="sd">            - angle_radians: circumferential position around muscle (0 = anterior)</span>
<span class="sd">            </span>
<span class="sd">            If None, uses single position at anatomical muscle belly center computed</span>
<span class="sd">            from the center of mass of all motor unit territories.</span>
<span class="sd">            </span>
<span class="sd">            Multiple positions enable spatial analysis of EMG characteristics across</span>
<span class="sd">            different muscle regions. Example positions:</span>
<span class="sd">            - [(0, 0)]: Single center position</span>
<span class="sd">            - [(0, 0), (-10, 0), (10, 0)]: Proximal-center-distal sequence</span>
<span class="sd">            - [(0, 0), (0, π/2), (0, π)]: Circumferential positions</span>
<span class="sd">        </span>
<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        resulting_muaps_array : numpy.ndarray</span>
<span class="sd">            Generated MUAP templates after calling simulate_muaps().</span>
<span class="sd">            Shape: (n_positions, n_motor_units, n_electrode_rows, n_electrode_cols, n_time_samples)</span>
<span class="sd">        </span>
<span class="sd">        surface_emg__tensor : numpy.ndarray  </span>
<span class="sd">            Generated surface EMG signals after calling simulate_surface_emg().</span>
<span class="sd">            Shape: (n_positions, n_pools, n_electrode_rows, n_electrode_cols, n_time_samples)</span>
<span class="sd">        </span>
<span class="sd">        noisy_surface_emg : numpy.ndarray</span>
<span class="sd">            Surface EMG with added noise after calling add_noise().</span>
<span class="sd">            Same shape as surface_emg__tensor.</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If any input parameter has incorrect type (enforced by beartype decorator).</span>
<span class="sd">        </span>
<span class="sd">        ValueError</span>
<span class="sd">            If muscle_model is empty or if electrode parameters are physically unrealistic</span>
<span class="sd">            (e.g., negative dimensions, impossible conductivity values).</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Standard Configuration:**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; muscle = myogen.simulator.Muscle(...)</span>
<span class="sd">        &gt;&gt;&gt; surface_emg = SurfaceEMG(</span>
<span class="sd">        ...     muscle_model=muscle,</span>
<span class="sd">        ...     sampling_frequency__Hz=2048,</span>
<span class="sd">        ...     electrode_grid_dimensions__rows_cols=(8, 8),</span>
<span class="sd">        ...     MUs_to_simulate=list(range(10))  # First 10 motor units</span>
<span class="sd">        ... )</span>
<span class="sd">        </span>
<span class="sd">        **High-Resolution Configuration:**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; surface_emg = SurfaceEMG(</span>
<span class="sd">        ...     muscle_model=muscle,</span>
<span class="sd">        ...     sampling_frequency__Hz=4096,  # Higher temporal resolution</span>
<span class="sd">        ...     sampling_points_in_t_and_z_domains=512,  # Higher spatial resolution</span>
<span class="sd">        ...     electrode_grid_dimensions__rows_cols=(16, 8),  # More electrodes</span>
<span class="sd">        ...     inter_electrode_distance__mm=2,  # Higher spatial sampling</span>
<span class="sd">        ... )</span>
<span class="sd">        </span>
<span class="sd">        **Multi-Position Spatial Analysis:**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; positions = [</span>
<span class="sd">        ...     (0, 0),                    # Center</span>
<span class="sd">        ...     (-8, np.deg2rad(0)),      # 8mm proximal  </span>
<span class="sd">        ...     (8, np.deg2rad(0)),       # 8mm distal</span>
<span class="sd">        ...     (0, np.deg2rad(90)),      # 90° circumferential</span>
<span class="sd">        ... ]</span>
<span class="sd">        &gt;&gt;&gt; surface_emg = SurfaceEMG(</span>
<span class="sd">        ...     muscle_model=muscle,</span>
<span class="sd">        ...     electrode_grid_center_positions=positions</span>
<span class="sd">        ... )</span>
<span class="sd">        </span>
<span class="sd">        **Thin Subcutaneous Layer Configuration:**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; surface_emg = SurfaceEMG(</span>
<span class="sd">        ...     muscle_model=muscle,</span>
<span class="sd">        ...     fat_thickness__mm=0.5,    # Thin fat layer</span>
<span class="sd">        ...     skin_thickness__mm=0.8,   # Thin skin layer</span>
<span class="sd">        ... )  # Results in higher amplitude, more spatially localized MUAPs</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Parameter Interdependencies:**</span>
<span class="sd">        - Tissue thicknesses affect MUAP amplitudes and spatial spread</span>
<span class="sd">        - Conductivity values determine volume conductor characteristics</span>
<span class="sd">        - Electrode spacing affects spatial aliasing and resolution</span>
<span class="sd">        - Sampling frequencies must satisfy Nyquist criterion for MUAP frequencies</span>
<span class="sd">        </span>
<span class="sd">        **Computational Considerations:**</span>
<span class="sd">        - Memory usage ∝ n_positions × n_MUs × electrode_grid_area × time_samples</span>
<span class="sd">        - Computation time ∝ n_MUs × n_fibers_per_MU × n_positions × grid_area</span>
<span class="sd">        - For large simulations, consider parameter optimization or parallel processing</span>
<span class="sd">        </span>
<span class="sd">        **Biological Realism:**</span>
<span class="sd">        - All default parameters based on published anatomical/physiological studies</span>
<span class="sd">        - Parameter ranges validated against experimental EMG data</span>
<span class="sd">        - Maintains physiological relationships between related parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">muscle_model</span> <span class="o">=</span> <span class="n">muscle_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_frequency__Hz</span> <span class="o">=</span> <span class="n">sampling_frequency__Hz</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_conduction_velocity__mm_s</span> <span class="o">=</span> <span class="n">mean_conduction_velocity__mm_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_points_in_t_and_z_domains</span> <span class="o">=</span> <span class="n">sampling_points_in_t_and_z_domains</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_points_in_theta_domain</span> <span class="o">=</span> <span class="n">sampling_points_in_theta_domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span> <span class="o">=</span> <span class="n">MUs_to_simulate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean_fiber_length__mm</span> <span class="o">=</span> <span class="n">mean_fiber_length__mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">var_fiber_length__mm</span> <span class="o">=</span> <span class="n">var_fiber_length__mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius_bone__mm</span> <span class="o">=</span> <span class="n">radius_bone__mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fat_thickness__mm</span> <span class="o">=</span> <span class="n">fat_thickness__mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skin_thickness__mm</span> <span class="o">=</span> <span class="n">skin_thickness__mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">muscle_conductivity_radial__S_m</span> <span class="o">=</span> <span class="n">muscle_conductivity_radial__S_m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">muscle_conductivity_longitudinal__S_m</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">muscle_conductivity_longitudinal__S_m</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fat_conductivity__S_m</span> <span class="o">=</span> <span class="n">fat_conductivity__S_m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skin_conductivity__S_m</span> <span class="o">=</span> <span class="n">skin_conductivity__S_m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_inclination_angle__deg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">electrode_grid_inclination_angle__deg</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_dimensions__rows_cols</span> <span class="o">=</span> <span class="n">electrode_grid_dimensions__rows_cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inter_electrode_distance__mm</span> <span class="o">=</span> <span class="n">inter_electrode_distance__mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">electrode_radius__mm</span> <span class="o">=</span> <span class="n">electrode_radius__mm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_center_positions</span> <span class="o">=</span> <span class="n">electrode_grid_center_positions</span>

        <span class="c1"># Convert sampling frequency from Hz to kHz for internal calculations</span>
        <span class="c1"># (Historical convention in the simulation framework)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_frequency__kHz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_frequency__Hz</span> <span class="o">/</span> <span class="mf">1000.0</span></div>


<div class="viewcode-block" id="SurfaceEMG.simulate_muaps">
<a class="viewcode-back" href="../../../../../generated/myogen.simulator.SurfaceEMG.html#myogen.simulator.SurfaceEMG.simulate_muaps">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_muaps</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">show_plots</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MUAP_SHAPE__TENSOR</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate surface EMG Motor Unit Action Potentials (MUAPs) for the FDI muscle.</span>

<span class="sd">        This function implements a comprehensive biophysical model that simulates surface EMG</span>
<span class="sd">        signals by computing the electrical activity of individual muscle fibers within motor</span>
<span class="sd">        units and their propagation through a multi-layered volume conductor (muscle, fat, skin).</span>

<span class="sd">        The simulation is optimized for multiple electrode positions by reusing computationally</span>
<span class="sd">        expensive matrix calculations across positions, significantly reducing simulation time</span>
<span class="sd">        for spatial EMG analysis.</span>

<span class="sd">        Scientific Basis</span>
<span class="sd">        ---------------</span>
<span class="sd">        The simulation implements the forward problem of EMG using:</span>

<span class="sd">        1. **Cylindrical Volume Conductor Model**: The limb is modeled as a multi-layered</span>
<span class="sd">        cylinder with realistic tissue conductivities accounting for anisotropy in muscle tissue.</span>

<span class="sd">        2. **Action Potential Propagation**: Intracellular action potentials propagate along</span>
<span class="sd">        muscle fibers with physiologically realistic conduction velocities and fiber lengths.</span>

<span class="sd">        3. **Spatial Integration**: Surface potentials are computed by spatially integrating</span>
<span class="sd">        contributions from all active muscle fibers within each motor unit territory.</span>

<span class="sd">        Optimization Strategy</span>
<span class="sd">        --------------------</span>
<span class="sd">        For multiple electrode positions, the function employs matrix reuse optimization:</span>
<span class="sd">        - Computes position-independent matrices (A_matrix, B_incomplete) once per fiber</span>
<span class="sd">        - Reuses these matrices across all electrode positions</span>
<span class="sd">        - Reduces computational complexity from O(n_positions × n_fibers × matrix_ops)</span>
<span class="sd">        to O(n_fibers × matrix_ops + n_positions × vector_ops)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        muscle_model : Muscle</span>
<span class="sd">            Pre-computed muscle model containing motor unit territories, fiber distributions,</span>
<span class="sd">            and recruitment thresholds. Should be generated using the myogen.simulator.Muscle class.</span>

<span class="sd">        sampling_frequency__Hz : float, default=2048.0</span>
<span class="sd">            Temporal sampling frequency for MUAP signals. Higher frequencies provide better</span>
<span class="sd">            temporal resolution but increase computational cost. Typical range: 1024-4096 Hz.</span>

<span class="sd">        mean_conduction_velocity__mm_s : float, defuault=4.1</span>
<span class="sd">            Mean conduction velocity of action potentials along muscle fibers.</span>
<span class="sd">            Based on experimental measurements (Botelho et al., 2019).</span>
<span class="sd">            Typical range for FDI: 3.5-4.5 mm/s.</span>

<span class="sd">        sampling_points_in_t_and_z_domains : int, default=256</span>
<span class="sd">            Spatial and temporal discretization resolution for numerical integration.</span>
<span class="sd">            Higher values improve accuracy but increase computational cost exponentially.</span>

<span class="sd">        sampling_points_in_theta_domain : int, default=180</span>
<span class="sd">            Angular discretization for cylindrical coordinate system.</span>
<span class="sd">            180 points provides 2° angular resolution, sufficient for most applications.</span>

<span class="sd">        MUs_to_simulate : list[int] or None, default=None</span>
<span class="sd">            Indices of motor units to simulate. If None, simulates all motor units in the model.</span>
<span class="sd">            For computational efficiency, consider simulating subsets for initial analysis.</span>

<span class="sd">        mean_fiber_length__mm : float, default=32</span>
<span class="sd">            Mean muscle fiber length based on anatomical measurements (Jacobson et al., 1992).</span>
<span class="sd">            Affects MUAP duration and amplitude characteristics.</span>

<span class="sd">        var_fiber_length__mm : float, default=3</span>
<span class="sd">            Standard deviation of fiber length distribution. Introduces realistic variability</span>
<span class="sd">            in MUAP shapes within motor units. Typical range: 2-5 mm.</span>

<span class="sd">        radius_bone__mm : float, default=0</span>
<span class="sd">            Inner bone radius for cylindrical volume conductor model.</span>
<span class="sd">            Set to 0 for surface EMG applications where bone effects are minimal.</span>

<span class="sd">        fat_thickness__mm : float, default=1</span>
<span class="sd">            Subcutaneous fat layer thickness. Significantly affects MUAP amplitude and</span>
<span class="sd">            spatial distribution. Based on ultrasound measurements (Störchle et al., 2018).</span>

<span class="sd">        skin_thickness__mm : float, default=1</span>
<span class="sd">            Skin layer thickness. Less critical parameter but affects high-frequency</span>
<span class="sd">            components of MUAPs. Based on histological measurements (Brodar, 1960).</span>

<span class="sd">        muscle_conductivity_radial__S_m : float, default=0.09</span>
<span class="sd">            Muscle tissue conductivity in radial direction (perpendicular to fibers).</span>
<span class="sd">            Muscle tissue exhibits anisotropic conductivity due to fiber orientation.</span>

<span class="sd">        muscle_conductivity_longitudinal__S_m : float, default=0.4</span>
<span class="sd">            Muscle tissue conductivity in longitudinal direction (parallel to fibers).</span>
<span class="sd">            Approximately 4-5x higher than radial conductivity due to fiber structure.</span>

<span class="sd">        fat_conductivity__S_m : float, default=0.041</span>
<span class="sd">            Subcutaneous fat tissue conductivity. Low conductivity acts as electrical</span>
<span class="sd">            insulator, spatially smoothing MUAP patterns.</span>

<span class="sd">        skin_conductivity__S_m : float, default=1</span>
<span class="sd">            Skin tissue conductivity. Relatively high conductivity provides good</span>
<span class="sd">            electrical coupling with electrodes.</span>

<span class="sd">        electrode_grid_inclination_angle__deg : float, default=0</span>
<span class="sd">            Rotation angle of electrode grid relative to muscle fiber direction.</span>
<span class="sd">            0° = aligned with fibers, 90° = perpendicular to fibers.</span>
<span class="sd">            Affects MUAP propagation patterns in multi-electrode recordings.</span>

<span class="sd">        electrode_grid_dimensions__rows_cols : tuple[int, int], default=(8, 8)</span>
<span class="sd">            Number of electrode rows and columns in the recording grid.</span>
<span class="sd">            Common configurations: (8,8), (16,8), (13,5) for high-density sEMG.</span>

<span class="sd">        inter_electrode_distance__mm : float, default=4</span>
<span class="sd">            Distance between adjacent electrodes in the grid.</span>
<span class="sd">            Affects spatial resolution and crosstalk. Typical range: 2-10 mm.</span>

<span class="sd">        electrode_radius__mm : float, default=0.75</span>
<span class="sd">            Physical radius of individual electrodes. Affects spatial averaging</span>
<span class="sd">            and signal-to-noise ratio. Standard clinical electrodes: 0.5-2 mm.</span>

<span class="sd">        electrode_grid_center_positions : list[tuple[float, float]] or None, default=None</span>
<span class="sd">            List of electrode grid center positions in cylindrical coordinates:</span>
<span class="sd">            [(z_position_mm, angle_radians), ...] where:</span>
<span class="sd">            - z_position_mm: position along muscle fiber direction</span>
<span class="sd">            - angle_radians: circumferential position around muscle</span>

<span class="sd">            If None, uses single position at anatomical muscle belly center.</span>
<span class="sd">            For spatial analysis, specify multiple positions to sample different</span>
<span class="sd">            regions of the muscle.</span>

<span class="sd">        show_plots : bool, default=False</span>
<span class="sd">            Whether to display visualization plots showing motor unit territories</span>
<span class="sd">            and fiber distributions. Useful for model validation and debugging.</span>

<span class="sd">        verbose : bool, default=True</span>
<span class="sd">            Whether to print progress information including simulation time,</span>
<span class="sd">            number of positions, and output array dimensions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MULTI_POSITION_MUAP_SHAPE__TENSOR : numpy.ndarray</span>
<span class="sd">            5D array containing simulated MUAPs with shape:</span>
<span class="sd">            (n_positions, n_motor_units, n_electrode_rows, n_electrode_cols, n_time_samples)</span>

<span class="sd">            - n_positions: Number of electrode grid positions</span>
<span class="sd">            - n_motor_units: Number of simulated motor units</span>
<span class="sd">            - n_electrode_rows, n_electrode_cols: Electrode grid dimensions</span>
<span class="sd">            - n_time_samples: Number of temporal samples per MUAP</span>

<span class="sd">            Units: Volts (typically µV range for surface EMG)</span>

<span class="sd">            The array can be indexed as:</span>
<span class="sd">            muaps[position_idx, mu_idx, row, col, :] -&gt; time series for specific electrode</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If muscle_model contains no valid motor units or if electrode parameters</span>
<span class="sd">            are physically unrealistic.</span>

<span class="sd">        TypeError</span>
<span class="sd">            If input parameters have incorrect types (enforced by beartype decorator).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Computational Complexity**:</span>
<span class="sd">        - Time complexity: O(n_positions × n_motor_units × n_fibers_per_MU × grid_size)</span>
<span class="sd">        - Space complexity: O(n_positions × n_motor_units × grid_size × n_time_samples)</span>
<span class="sd">        - For large simulations, consider using parallel processing or reducing parameters.</span>

<span class="sd">        **Memory Usage**:</span>
<span class="sd">        - Output array size scales as n_positions × n_MUs × grid_area × n_samples</span>
<span class="sd">        - Example: 8 positions × 100 MUs × 64 electrodes × 256 samples ≈ 100 MB</span>

<span class="sd">        **Validation Recommendations**:</span>
<span class="sd">        - Compare single-fiber MUAPs with analytical solutions for simple geometries</span>
<span class="sd">        - Verify MUAP amplitude scaling with electrode distance</span>
<span class="sd">        - Check temporal patterns match expected conduction velocity effects</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Basic single-position simulation:**</span>

<span class="sd">        &gt;&gt;&gt; muscle = Muscle(...)  # Pre-computed muscle model</span>
<span class="sd">        &gt;&gt;&gt; muaps = simulate_muaps(</span>
<span class="sd">        ...     muscle_model=muscle,</span>
<span class="sd">        ...     MUs_to_simulate=[0, 1, 2],  # First 3 motor units</span>
<span class="sd">        ...     electrode_grid_dimensions__rows_cols=(8, 8)</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;MUAP shape: {muaps.shape}&quot;)  # (1, 3, 8, 8, 256)</span>

<span class="sd">        **Multi-position spatial analysis:**</span>

<span class="sd">        &gt;&gt;&gt; positions = [</span>
<span class="sd">        ...     (0, 0),                      # Center</span>
<span class="sd">        ...     (-10, np.deg2rad(0)),       # 10mm proximal</span>
<span class="sd">        ...     (10, np.deg2rad(0)),        # 10mm distal</span>
<span class="sd">        ...     (0, np.deg2rad(90))         # 90° rotation</span>
<span class="sd">        ... ]</span>
<span class="sd">        &gt;&gt;&gt; muaps_multi = simulate_muaps(</span>
<span class="sd">        ...     muscle_model=muscle,</span>
<span class="sd">        ...     electrode_grid_center_positions=positions,</span>
<span class="sd">        ...     MUs_to_simulate=list(range(20))  # First 20 MUs</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Multi-position shape: {muaps_multi.shape}&quot;)  # (4, 20, 8, 8, 256)</span>

<span class="sd">        **High-resolution temporal analysis:**</span>

<span class="sd">        &gt;&gt;&gt; muaps_hires = simulate_muaps(</span>
<span class="sd">        ...     muscle_model=muscle,</span>
<span class="sd">        ...     sampling_frequency__Hz=4096,  # Higher temporal resolution</span>
<span class="sd">        ...     sampling_points_in_t_and_z_domains=512,  # More spatial samples</span>
<span class="sd">        ...     MUs_to_simulate=[0]  # Single MU for detailed analysis</span>
<span class="sd">        ... )</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        myogen.simulator.Muscle : For creating muscle models with motor unit territories</span>
<span class="sd">        myogen.simulator.emg.surface.og_with_optimized_simulation.Simulate_fiber :</span>
<span class="sd">            Low-level fiber simulation function</span>
<span class="sd">        myogen.utils.plotting.muscle : For visualizing muscle models and simulation results</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Starting FDI muscle EMG simulation...&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Muscle model: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">muscle_model</span><span class="o">.</span><span class="n">resulting_number_of_innervated_fibers</span><span class="p">)</span><span class="si">}</span><span class="s2"> motor units&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Set default MUs_to_simulate if not provided - simulate all available motor units</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">muscle_model</span><span class="o">.</span><span class="n">resulting_number_of_innervated_fibers</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;No specific MUs specified - simulating all </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">)</span><span class="si">}</span><span class="s2"> motor units&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Set default electrode centers if not provided - single position at muscle center</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_center_positions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_center_positions</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>  <span class="c1"># Single default position</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Using default electrode position at anatomical muscle center&quot;</span><span class="p">)</span>

        <span class="c1"># Calculate derived geometric parameters for the volume conductor model</span>
        <span class="c1"># Innervation zone variance based on fiber length distribution (Botelho, 2019)</span>
        <span class="n">innervation_zone_variance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean_fiber_length__mm</span> <span class="o">/</span> <span class="mi">10</span>

        <span class="c1"># Total radius includes all tissue layers for cylindrical volume conductor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius_total</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">muscle_model</span><span class="o">.</span><span class="n">radius__mm</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fat_thickness__mm</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">skin_thickness__mm</span>
        <span class="p">)</span>

        <span class="c1"># Extract motor unit fiber counts from the pre-computed muscle model</span>
        <span class="n">number_of_fibers_per_MUs</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">muscle_model</span><span class="o">.</span><span class="n">resulting_number_of_innervated_fibers</span>
        <span class="p">)</span>

        <span class="c1"># Create temporal sampling array for MUAP time series</span>
        <span class="c1"># Time array spans from 0 to (N-1)/Fs to avoid endpoint duplication in FFT</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_points_in_t_and_z_domains</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_frequency__kHz</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_points_in_t_and_z_domains</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Generate color map for motor unit visualization (if plots are enabled)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s2">&quot;tab20&quot;</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">)))</span>

        <span class="c1"># Pre-calculate innervation zone positions for all motor units</span>
        <span class="c1"># Innervation zones are randomly distributed within physiological bounds</span>
        <span class="c1"># This introduces realistic variability in MUAP shapes</span>
        <span class="n">innervation_zones</span> <span class="o">=</span> <span class="n">RANDOM_GENERATOR</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
            <span class="n">low</span><span class="o">=-</span><span class="n">innervation_zone_variance</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">high</span><span class="o">=</span><span class="n">innervation_zone_variance</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Calculate default electrode center position based on muscle anatomy</span>
        <span class="c1"># Uses center of mass of all fiber positions as anatomically-informed default</span>
        <span class="n">default_center</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_center_positions</span><span class="p">:</span>
            <span class="n">all_fiber_positions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">all_innervation_zones</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Collect all fiber positions to compute anatomical center</span>
            <span class="k">for</span> <span class="n">MU_number</span><span class="p">,</span> <span class="n">MU_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">):</span>
                <span class="n">number_of_fibers</span> <span class="o">=</span> <span class="n">number_of_fibers_per_MUs</span><span class="p">[</span><span class="n">MU_index</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">number_of_fibers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">position_of_fibers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">muscle_model</span><span class="o">.</span><span class="n">resulting_fiber_assignment</span><span class="p">(</span>
                    <span class="n">MU_index</span>
                <span class="p">)</span>
                <span class="n">innervation_zone</span> <span class="o">=</span> <span class="n">innervation_zones</span><span class="p">[</span><span class="n">MU_number</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">fiber_number</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fibers</span><span class="p">):</span>
                    <span class="c1"># Convert Cartesian coordinates to angular position for center calculation</span>
                    <span class="n">all_fiber_positions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">position_of_fibers</span><span class="p">[</span><span class="n">fiber_number</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># type: ignore</span>
                    <span class="p">)</span>
                    <span class="n">all_innervation_zones</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">innervation_zone</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_fiber_positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Anatomical center = center of mass of innervation zones and fiber positions</span>
                <span class="n">default_center</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span>
                        <span class="n">all_innervation_zones</span>
                    <span class="p">),</span>  <span class="c1"># Z-position (along fiber direction)</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">all_fiber_positions</span><span class="p">)</span>
                    <span class="p">),</span>  <span class="c1"># Angular position (degrees)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Fallback to geometric center if no fibers found</span>
                <span class="n">default_center</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Computed anatomical center: z=</span><span class="si">{</span><span class="n">default_center</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">mm, θ=</span><span class="si">{</span><span class="n">default_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">°&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Prepare electrode centers list with unit conversion (radians to degrees)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_centers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">default_center</span>
            <span class="k">if</span> <span class="n">electrode_grid_center</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="p">(</span><span class="n">electrode_grid_center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">electrode_grid_center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">electrode_grid_center</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_center_positions</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Electrode positions: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_centers</span><span class="p">)</span><span class="si">}</span><span class="s2"> position(s)&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Electrode grid: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_dimensions__rows_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">×</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_dimensions__rows_cols</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_dimensions__rows_cols</span><span class="p">)</span><span class="si">}</span><span class="s2"> channels&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Initialize output array for all results</span>
        <span class="c1"># Shape: (n_positions, N_MU, electrode_rows, electrode_cols, time_samples)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_centers</span><span class="p">),</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">),</span>
                <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_dimensions__rows_cols</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">array_size_mb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Output array size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">array_size_mb</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> MB)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Main simulation loop - process each motor unit independently</span>
        <span class="k">for</span> <span class="n">MU_number</span><span class="p">,</span> <span class="n">MU_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">):</span>
            <span class="n">number_of_fibers</span> <span class="o">=</span> <span class="n">number_of_fibers_per_MUs</span><span class="p">[</span><span class="n">MU_index</span><span class="p">]</span>

            <span class="c1"># Skip motor units with no assigned fibers</span>
            <span class="k">if</span> <span class="n">number_of_fibers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Warning: No fibers assigned to MU </span><span class="si">{</span><span class="n">MU_number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">. Skipping.&quot;</span>
                    <span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Get spatial positions of all fibers in this motor unit</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">position_of_fibers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">muscle_model</span><span class="o">.</span><span class="n">resulting_fiber_assignment</span><span class="p">(</span>
                <span class="n">MU_index</span>
            <span class="p">)</span>
            <span class="n">innervation_zone</span> <span class="o">=</span> <span class="n">innervation_zones</span><span class="p">[</span><span class="n">MU_number</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Processing MU </span><span class="si">{</span><span class="n">MU_number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">number_of_fibers</span><span class="si">}</span><span class="s2"> fibers&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Optional visualization of motor unit territory</span>
            <span class="k">if</span> <span class="n">show_plots</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
                <span class="c1"># Draw muscle boundary</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
                    <span class="n">patches</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span>
                        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">muscle_model</span><span class="o">.</span><span class="n">radius__mm</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Motor Unit </span><span class="si">{</span><span class="n">MU_number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> Territory&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;X position (mm)&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Y position (mm)&quot;</span><span class="p">)</span>

            <span class="c1"># Matrix optimization variables for computational efficiency</span>
            <span class="c1"># These matrices contain position-independent calculations that can be reused</span>
            <span class="n">A_matrix</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">B_incomplete</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># Process each fiber within the motor unit</span>
            <span class="k">for</span> <span class="n">pos_idx</span><span class="p">,</span> <span class="n">electrode_grid_center</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_centers</span>
            <span class="p">):</span>
                <span class="k">for</span> <span class="n">fiber_number</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span>
                    <span class="nb">range</span><span class="p">(</span><span class="n">number_of_fibers</span><span class="p">),</span>
                    <span class="n">desc</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;MU </span><span class="si">{</span><span class="n">MU_number</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> Position </span><span class="si">{</span><span class="n">pos_idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="p">):</span>
                    <span class="c1"># Get fiber position in Cartesian coordinates (mm)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fiber_position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">position_of_fibers</span><span class="p">[</span><span class="n">fiber_number</span><span class="p">]</span>

                    <span class="c1"># Add fiber to visualization plot</span>
                    <span class="k">if</span> <span class="n">show_plots</span><span class="p">:</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span>
                            <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fiber_position</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">MU_number</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span>
                        <span class="p">)</span>  <span class="c1"># type: ignore</span>

                    <span class="c1"># Calculate fiber distance from muscle center (radial position)</span>
                    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">fiber_position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fiber_position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span>
                    <span class="p">)</span>

                    <span class="c1"># Generate realistic fiber length with biological variability</span>
                    <span class="n">fiber_length__mm</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mean_fiber_length__mm</span>
                        <span class="o">+</span> <span class="n">RANDOM_GENERATOR</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span>
                            <span class="n">low</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">var_fiber_length__mm</span><span class="p">,</span>
                            <span class="n">high</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">var_fiber_length__mm</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

                    <span class="c1"># Calculate fiber end positions relative to innervation zone</span>
                    <span class="c1"># L1, L2 = distances from innervation zone to fiber ends</span>
                    <span class="n">L2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">innervation_zone</span> <span class="o">-</span> <span class="n">fiber_length__mm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Proximal end</span>
                    <span class="n">L1</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">innervation_zone</span> <span class="o">+</span> <span class="n">fiber_length__mm</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Distal end</span>

                    <span class="c1"># OPTIMIZATION: For the first fiber, compute expensive matrices once</span>
                    <span class="c1"># For subsequent fibers, reuse these matrices across all electrode positions</span>
                    <span class="k">if</span> <span class="n">fiber_number</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">A_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="c1"># Compute matrices for the first electrode position</span>
                        <span class="n">phi_temp</span><span class="p">,</span> <span class="n">A_matrix</span><span class="p">,</span> <span class="n">B_incomplete</span> <span class="o">=</span> <span class="n">simulate_fiber</span><span class="p">(</span>
                            <span class="n">Fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sampling_frequency__kHz</span><span class="p">,</span>
                            <span class="n">v</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_conduction_velocity__mm_s</span><span class="p">,</span>
                            <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_points_in_t_and_z_domains</span><span class="p">,</span>
                            <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_points_in_theta_domain</span><span class="p">,</span>
                            <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius_total</span><span class="p">,</span>
                            <span class="n">r_bone</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius_bone__mm</span><span class="p">,</span>
                            <span class="n">th_fat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fat_thickness__mm</span><span class="p">,</span>
                            <span class="n">th_skin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">skin_thickness__mm</span><span class="p">,</span>
                            <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                            <span class="n">L1</span><span class="o">=</span><span class="n">L1</span><span class="p">,</span>
                            <span class="n">L2</span><span class="o">=</span><span class="n">L2</span><span class="p">,</span>
                            <span class="n">zi</span><span class="o">=</span><span class="n">innervation_zone</span><span class="p">,</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_inclination_angle__deg</span><span class="p">,</span>
                            <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_dimensions__rows_cols</span><span class="p">,</span>
                            <span class="n">center</span><span class="o">=</span><span class="n">electrode_grid_center</span><span class="p">,</span>
                            <span class="n">d_ele</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inter_electrode_distance__mm</span><span class="p">,</span>
                            <span class="n">rele</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_radius__mm</span><span class="p">,</span>
                            <span class="n">sig_muscle_rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">muscle_conductivity_radial__S_m</span><span class="p">,</span>
                            <span class="n">sig_muscle_z</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">muscle_conductivity_longitudinal__S_m</span><span class="p">,</span>
                            <span class="n">sig_skin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">skin_conductivity__S_m</span><span class="p">,</span>
                            <span class="n">sig_fat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fat_conductivity__S_m</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="c1"># Add first position result to output array</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span><span class="p">[</span><span class="n">pos_idx</span><span class="p">,</span> <span class="n">MU_number</span><span class="p">]</span> <span class="o">+=</span> <span class="n">phi_temp</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># For subsequent fibers, reuse matrices for all electrode positions</span>
                        <span class="c1"># This provides significant computational speedup for multi-position simulations</span>
                        <span class="n">phi_temp</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">simulate_fiber</span><span class="p">(</span>
                            <span class="n">Fs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_sampling_frequency__kHz</span><span class="p">,</span>
                            <span class="n">v</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_conduction_velocity__mm_s</span><span class="p">,</span>
                            <span class="n">N</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_points_in_t_and_z_domains</span><span class="p">,</span>
                            <span class="n">M</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_points_in_theta_domain</span><span class="p">,</span>
                            <span class="n">r</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius_total</span><span class="p">,</span>
                            <span class="n">r_bone</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">radius_bone__mm</span><span class="p">,</span>
                            <span class="n">th_fat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fat_thickness__mm</span><span class="p">,</span>
                            <span class="n">th_skin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">skin_thickness__mm</span><span class="p">,</span>
                            <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                            <span class="n">L1</span><span class="o">=</span><span class="n">L1</span><span class="p">,</span>
                            <span class="n">L2</span><span class="o">=</span><span class="n">L2</span><span class="p">,</span>
                            <span class="n">zi</span><span class="o">=</span><span class="n">innervation_zone</span><span class="p">,</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_inclination_angle__deg</span><span class="p">,</span>
                            <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_dimensions__rows_cols</span><span class="p">,</span>
                            <span class="n">center</span><span class="o">=</span><span class="n">electrode_grid_center</span><span class="p">,</span>
                            <span class="n">d_ele</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">inter_electrode_distance__mm</span><span class="p">,</span>
                            <span class="n">rele</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_radius__mm</span><span class="p">,</span>
                            <span class="n">sig_muscle_rho</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">muscle_conductivity_radial__S_m</span><span class="p">,</span>
                            <span class="n">sig_muscle_z</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">muscle_conductivity_longitudinal__S_m</span><span class="p">,</span>
                            <span class="n">sig_skin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">skin_conductivity__S_m</span><span class="p">,</span>
                            <span class="n">sig_fat</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fat_conductivity__S_m</span><span class="p">,</span>
                            <span class="n">A_matrix</span><span class="o">=</span><span class="n">A_matrix</span><span class="p">,</span>  <span class="c1"># Reuse cached matrix</span>
                            <span class="n">B_incomplete</span><span class="o">=</span><span class="n">B_incomplete</span><span class="p">,</span>  <span class="c1"># Reuse cached matrix</span>
                        <span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span><span class="p">[</span><span class="n">pos_idx</span><span class="p">,</span> <span class="n">MU_number</span><span class="p">]</span> <span class="o">+=</span> <span class="n">phi_temp</span>

            <span class="c1"># Display motor unit territory visualization</span>
            <span class="k">if</span> <span class="n">show_plots</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s2">&quot;box&quot;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="c1"># Print simulation summary and performance metrics</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">simulation_time</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulation completed successfully!&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total simulation time: </span><span class="si">{</span><span class="n">simulation_time</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Generated MUAPs for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">electrode_grid_center_positions</span><span class="p">)</span><span class="si">}</span><span class="s2"> electrode position(s)&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Simulated </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">)</span><span class="si">}</span><span class="s2"> motor units&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output array shape: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Output array size: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span><span class="o">.</span><span class="n">nbytes</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mi">1024</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> MB&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Time per motor unit: </span><span class="si">{</span><span class="n">simulation_time</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> seconds&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">60</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span></div>


<div class="viewcode-block" id="SurfaceEMG.simulate_surface_emg">
<a class="viewcode-back" href="../../../../../generated/myogen.simulator.SurfaceEMG.html#myogen.simulator.SurfaceEMG.simulate_surface_emg">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_surface_emg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">motor_neuron_pool</span><span class="p">:</span> <span class="n">MotorNeuronPool</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate realistic surface EMG signals by convolving MUAP templates with motor neuron spike trains.</span>
<span class="sd">        </span>
<span class="sd">        This method implements the final step of surface EMG simulation by combining the previously</span>
<span class="sd">        computed Motor Unit Action Potential (MUAP) templates with physiologically realistic motor</span>
<span class="sd">        neuron firing patterns. The process involves temporal resampling to match simulation timesteps,</span>
<span class="sd">        convolution of spike trains with MUAP shapes, and summation across all active motor units</span>
<span class="sd">        for each electrode channel.</span>
<span class="sd">        </span>
<span class="sd">        The simulation can optionally use GPU acceleration (via CuPy) for efficient parallel processing of</span>
<span class="sd">        convolution operations across multiple electrode positions, motor units, and time points.</span>
<span class="sd">        If CuPy is not available, the simulation automatically falls back to CPU computation with NumPy.</span>
<span class="sd">        </span>
<span class="sd">        Scientific Background</span>
<span class="sd">        --------------------</span>
<span class="sd">        Surface EMG signals arise from the temporal and spatial summation of individual motor unit</span>
<span class="sd">        action potentials (MUAPs) as they propagate through tissue and are detected by surface</span>
<span class="sd">        electrodes. The mathematical relationship is:</span>
<span class="sd">        </span>
<span class="sd">        EMG(t) = Σᵢ Σⱼ MUAP_i(t - tᵢⱼ)</span>
<span class="sd">        </span>
<span class="sd">        Where:</span>
<span class="sd">        - i indexes motor units</span>
<span class="sd">        - j indexes spike times for motor unit i</span>
<span class="sd">        - MUAP_i(t) is the MUAP template for motor unit i</span>
<span class="sd">        - tᵢⱼ is the j-th spike time of motor unit i</span>
<span class="sd">        </span>
<span class="sd">        This summation is efficiently computed using convolution:</span>
<span class="sd">        EMG(t) = Σᵢ spike_train_i(t) ⊛ MUAP_i(t)</span>
<span class="sd">        </span>
<span class="sd">        Processing Pipeline</span>
<span class="sd">        ------------------</span>
<span class="sd">        1. **Temporal Resampling**: Adjust MUAP sampling rate to match motor neuron simulation timestep</span>
<span class="sd">        2. **Motor Unit Selection**: Identify active motor units from intersection of simulated MUs and spike trains</span>
<span class="sd">        3. **Convolution**: Convolve each spike train with corresponding MUAP template</span>
<span class="sd">        4. **Spatial Summation**: Sum contributions across all active motor units for each electrode</span>
<span class="sd">        5. **Multi-Position Processing**: Repeat for all electrode grid positions</span>
<span class="sd">        </span>
<span class="sd">        GPU Acceleration</span>
<span class="sd">        ---------------</span>
<span class="sd">        The method automatically uses GPU processing (if CuPy is available) for:</span>
<span class="sd">        - Large-scale convolution operations across multiple dimensions</span>
<span class="sd">        - Parallel processing of electrode positions and motor unit combinations</span>
<span class="sd">        - Efficient memory management for large EMG datasets</span>
<span class="sd">        </span>
<span class="sd">        If CuPy is not installed or GPU is unavailable, the method automatically falls back</span>
<span class="sd">        to CPU-based computation using NumPy with equivalent functionality.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        motor_neuron_pool : MotorNeuronPool</span>
<span class="sd">            Motor neuron pool containing spike trains and simulation parameters.</span>
<span class="sd">            Must contain:</span>
<span class="sd">            - spike_trains: Binary spike train matrix [n_pools, n_motor_units, n_time_samples]</span>
<span class="sd">            - timestep__ms: Simulation timestep in milliseconds</span>
<span class="sd">            - active_neuron_indices: List of active motor unit indices for each pool</span>
<span class="sd">            </span>
<span class="sd">            The motor neuron pool defines the temporal firing patterns that will be</span>
<span class="sd">            convolved with the MUAP templates to generate surface EMG signals.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        surface_emg__tensor : numpy.ndarray</span>
<span class="sd">            Multi-dimensional surface EMG signals with shape:</span>
<span class="sd">            (n_positions, n_pools, n_electrode_rows, n_electrode_cols, n_time_samples)</span>
<span class="sd">            </span>
<span class="sd">            Dimensions:</span>
<span class="sd">            - n_positions: Number of electrode grid positions</span>
<span class="sd">            - n_pools: Number of motor neuron pools (different simulation conditions)</span>
<span class="sd">            - n_electrode_rows: Number of electrode rows in grid</span>
<span class="sd">            - n_electrode_cols: Number of electrode columns in grid  </span>
<span class="sd">            - n_time_samples: Number of temporal samples in EMG signal</span>
<span class="sd">            </span>
<span class="sd">            Units: Volts (typically in microvolts range for surface EMG)</span>
<span class="sd">            </span>
<span class="sd">            The tensor can be indexed as:</span>
<span class="sd">            surface_emg[position_idx, pool_idx, row, col, :] -&gt; EMG time series for specific electrode</span>
<span class="sd">        </span>
<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            If simulate_muaps() has not been called first to generate MUAP templates.</span>
<span class="sd">            </span>
<span class="sd">        ValueError</span>
<span class="sd">            If motor_neuron_pool contains no active motor units or if there&#39;s a mismatch</span>
<span class="sd">            between simulated motor units and available spike trains.</span>
<span class="sd">            </span>
<span class="sd">        RuntimeError</span>
<span class="sd">            If GPU memory is insufficient for large simulations when using CuPy </span>
<span class="sd">            (will automatically fall back to CPU-based computation).</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **Computational Complexity:**</span>
<span class="sd">        - Time complexity: O(n_positions × n_pools × n_MUs × n_electrodes × n_time_samples)</span>
<span class="sd">        - Space complexity: O(n_positions × n_pools × n_electrodes × n_time_samples)</span>
<span class="sd">        - GPU acceleration (if available) provides 10-50x speedup for large simulations</span>
<span class="sd">        </span>
<span class="sd">        **Memory Requirements:**</span>
<span class="sd">        - Input MUAPs: n_positions × n_MUs × n_electrodes × n_time_samples × 8 bytes</span>
<span class="sd">        - Spike trains: n_pools × n_MUs × n_time_samples × 8 bytes</span>
<span class="sd">        - Output EMG: n_positions × n_pools × n_electrodes × n_time_samples × 8 bytes</span>
<span class="sd">        - Example: 4 positions × 10 pools × 100 MUs × 64 electrodes × 10000 samples ≈ 2 GB</span>
<span class="sd">        </span>
<span class="sd">        **Signal Characteristics:**</span>
<span class="sd">        - Amplitude range: typically 10-1000 μV for surface EMG</span>
<span class="sd">        - Frequency content: 10-500 Hz (depending on muscle and electrode configuration)</span>
<span class="sd">        - Temporal patterns reflect motor unit recruitment and firing rate modulation</span>
<span class="sd">        - Spatial patterns depend on motor unit territories and electrode positioning</span>
<span class="sd">        </span>
<span class="sd">        **Validation Recommendations:**</span>
<span class="sd">        - Verify EMG amplitude scaling with muscle activation level</span>
<span class="sd">        - Check frequency content matches physiological expectations</span>
<span class="sd">        - Ensure spatial patterns are consistent with motor unit territories</span>
<span class="sd">        - Compare multi-channel correlations with experimental data</span>
<span class="sd">        </span>
<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        **Basic Surface EMG Simulation:**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # First generate MUAP templates</span>
<span class="sd">        &gt;&gt;&gt; muaps = surface_emg.simulate_muaps()</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Create motor neuron pool with spike trains</span>
<span class="sd">        &gt;&gt;&gt; motor_pool = myogen.simulator.MotorNeuronPool(</span>
<span class="sd">        ...     spike_trains=spike_data,</span>
<span class="sd">        ...     timestep__ms=1.0,</span>
<span class="sd">        ...     active_neuron_indices=[[0, 1, 2, 3, 4]]  # First 5 MUs active</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Generate surface EMG</span>
<span class="sd">        &gt;&gt;&gt; emg_signals = surface_emg.simulate_surface_emg(motor_pool)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;EMG shape: {emg_signals.shape}&quot;)  # (1, 1, 8, 8, 10000)</span>
<span class="sd">        </span>
<span class="sd">        **Multi-Condition Simulation:**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Motor pool with multiple activation conditions</span>
<span class="sd">        &gt;&gt;&gt; motor_pool = myogen.simulator.MotorNeuronPool(</span>
<span class="sd">        ...     spike_trains=multi_condition_spikes,  # [n_conditions, n_MUs, n_samples]</span>
<span class="sd">        ...     timestep__ms=0.5,</span>
<span class="sd">        ...     active_neuron_indices=[</span>
<span class="sd">        ...         [0, 1, 2],           # Low activation: 3 MUs</span>
<span class="sd">        ...         [0, 1, 2, 3, 4, 5],  # Medium activation: 6 MUs</span>
<span class="sd">        ...         list(range(10))      # High activation: 10 MUs</span>
<span class="sd">        ...     ]</span>
<span class="sd">        ... )</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; emg_multi = surface_emg.simulate_surface_emg(motor_pool)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Multi-condition EMG: {emg_multi.shape}&quot;)  # (n_pos, 3, 8, 8, n_samples)</span>
<span class="sd">        </span>
<span class="sd">        **Analysis of Specific Electrodes:**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; emg = surface_emg.simulate_surface_emg(motor_pool)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Extract signal from center electrode</span>
<span class="sd">        &gt;&gt;&gt; center_row, center_col = 4, 4  # Center of 8x8 grid</span>
<span class="sd">        &gt;&gt;&gt; center_emg = emg[0, 0, center_row, center_col, :]</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; # Compute RMS amplitude across grid</span>
<span class="sd">        &gt;&gt;&gt; rms_amplitudes = np.sqrt(np.mean(emg[0, 0, :, :, :] ** 2, axis=2))</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;RMS amplitude map shape: {rms_amplitudes.shape}&quot;)  # (8, 8)</span>
<span class="sd">        </span>
<span class="sd">        **Multi-Position Comparison:**</span>
<span class="sd">        </span>
<span class="sd">        &gt;&gt;&gt; # Compare EMG characteristics across electrode positions</span>
<span class="sd">        &gt;&gt;&gt; emg = surface_emg.simulate_surface_emg(motor_pool)</span>
<span class="sd">        &gt;&gt;&gt; </span>
<span class="sd">        &gt;&gt;&gt; for pos_idx in range(emg.shape[0]):</span>
<span class="sd">        ...     pos_emg = emg[pos_idx, 0, :, :, :]</span>
<span class="sd">        ...     max_amplitude = np.max(np.abs(pos_emg))</span>
<span class="sd">        ...     print(f&quot;Position {pos_idx}: Max amplitude = {max_amplitude:.2f} μV&quot;)</span>
<span class="sd">        </span>
<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        simulate_muaps : Generate MUAP templates (must be called first)</span>
<span class="sd">        add_noise : Add measurement noise to simulated EMG signals</span>
<span class="sd">        myogen.simulator.MotorNeuronPool : Create motor neuron spike trains</span>
<span class="sd">        myogen.utils.plotting.surface_emg : Visualize simulated EMG signals</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Validate that MUAPs have been computed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;resulting_muaps_array&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="s2">&quot;MUAP templates have not been generated. Call simulate_muaps() first.&quot;</span>
            <span class="p">)</span>
        
        <span class="c1"># Temporal resampling to match motor neuron pool timestep</span>
        <span class="c1"># Note: resample function from scipy.signal</span>
        <span class="n">muap_shapes__tensor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">resample</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resulting_muaps_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_frequency__Hz</span><span class="p">)</span>
                <span class="o">//</span> <span class="p">(</span><span class="n">motor_neuron_pool</span><span class="o">.</span><span class="n">timestep__ms</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">))</span>

        <span class="c1"># Handle None case for MUs_to_simulate and convert to set for efficient lookup</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">MUs_to_simulate</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">muscle_model</span><span class="o">.</span><span class="n">resulting_number_of_innervated_fibers</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">MUs_to_simulate</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">MUs_to_simulate</span><span class="p">)</span>

        <span class="n">n_pools</span> <span class="o">=</span> <span class="n">motor_neuron_pool</span><span class="o">.</span><span class="n">spike_trains</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_positions</span> <span class="o">=</span> <span class="n">muap_shapes__tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_rows</span> <span class="o">=</span> <span class="n">muap_shapes__tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">n_cols</span> <span class="o">=</span> <span class="n">muap_shapes__tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

        <span class="c1"># Initialize the result array with the correct shape</span>
        <span class="c1"># The shape will depend on the length of the convolution result</span>
        <span class="n">sample_conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span>
            <span class="n">motor_neuron_pool</span><span class="o">.</span><span class="n">spike_trains</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">muap_shapes__tensor</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Perform the convolution and summation using GPU acceleration if available</span>
        <span class="k">if</span> <span class="n">HAS_CUPY</span><span class="p">:</span>
            <span class="c1"># Use GPU acceleration with CuPy</span>
            <span class="n">spike_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">motor_neuron_pool</span><span class="o">.</span><span class="n">spike_trains</span><span class="p">)</span>
            <span class="n">muap_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">muap_shapes__tensor</span><span class="p">)</span>
            <span class="n">surface_emg_gpu</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="n">n_positions</span><span class="p">,</span> <span class="n">n_pools</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_conv</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">mu_pool_idx</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_pools</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Simulating surface EMG (GPU)&quot;</span><span class="p">):</span>
                <span class="n">active_neuron_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">motor_neuron_pool</span><span class="o">.</span><span class="n">active_neuron_indices</span><span class="p">[</span><span class="n">mu_pool_idx</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">position_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_positions</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">row_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rows</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">col_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cols</span><span class="p">):</span>
                            <span class="c1"># Process all MUAPs for this combination on GPU</span>
                            <span class="n">convolutions</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="n">cp</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span>
                                        <span class="n">spike_gpu</span><span class="p">[</span><span class="n">mu_pool_idx</span><span class="p">,</span> <span class="n">muap_idx</span><span class="p">],</span>
                                        <span class="n">muap_gpu</span><span class="p">[</span><span class="n">position_idx</span><span class="p">,</span> <span class="n">muap_idx</span><span class="p">,</span> <span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">],</span>
                                        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">,</span>
                                    <span class="p">)</span>
                                    <span class="k">for</span> <span class="n">muap_idx</span> <span class="ow">in</span> <span class="n">MUs_to_simulate</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                                        <span class="n">active_neuron_indices</span>
                                    <span class="p">)</span>
                                <span class="p">]</span>
                            <span class="p">)</span>
                            <span class="c1"># Sum across MUAPs on GPU</span>
                            <span class="n">surface_emg_gpu</span><span class="p">[</span><span class="n">position_idx</span><span class="p">,</span> <span class="n">mu_pool_idx</span><span class="p">,</span> <span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">convolutions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="p">)</span>

            <span class="c1"># Transfer results back to CPU</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">surface_emg__tensor</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">surface_emg_gpu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Fallback to CPU computation with NumPy</span>
            <span class="n">surface_emg_cpu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="n">n_positions</span><span class="p">,</span> <span class="n">n_pools</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_conv</span><span class="p">))</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">mu_pool_idx</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_pools</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s2">&quot;Simulating surface EMG (CPU)&quot;</span><span class="p">):</span>
                <span class="n">active_neuron_indices</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
                    <span class="n">motor_neuron_pool</span><span class="o">.</span><span class="n">active_neuron_indices</span><span class="p">[</span><span class="n">mu_pool_idx</span><span class="p">]</span>
                <span class="p">)</span>

                <span class="k">for</span> <span class="n">position_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_positions</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">row_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_rows</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">col_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_cols</span><span class="p">):</span>
                            <span class="c1"># Process all MUAPs for this combination on CPU</span>
                            <span class="n">convolutions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                                <span class="p">[</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span>
                                        <span class="n">motor_neuron_pool</span><span class="o">.</span><span class="n">spike_trains</span><span class="p">[</span><span class="n">mu_pool_idx</span><span class="p">,</span> <span class="n">muap_idx</span><span class="p">],</span>
                                        <span class="n">muap_shapes__tensor</span><span class="p">[</span><span class="n">position_idx</span><span class="p">,</span> <span class="n">muap_idx</span><span class="p">,</span> <span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">],</span>
                                        <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;same&quot;</span><span class="p">,</span>
                                    <span class="p">)</span>
                                    <span class="k">for</span> <span class="n">muap_idx</span> <span class="ow">in</span> <span class="n">MUs_to_simulate</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                                        <span class="n">active_neuron_indices</span>
                                    <span class="p">)</span>
                                <span class="p">]</span>
                            <span class="p">)</span>
                            <span class="c1"># Sum across MUAPs on CPU</span>
                            <span class="n">surface_emg_cpu</span><span class="p">[</span><span class="n">position_idx</span><span class="p">,</span> <span class="n">mu_pool_idx</span><span class="p">,</span> <span class="n">row_idx</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">convolutions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">surface_emg__tensor</span> <span class="o">=</span> <span class="n">surface_emg_cpu</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_emg__tensor</span></div>


<div class="viewcode-block" id="SurfaceEMG.add_noise">
<a class="viewcode-back" href="../../../../../generated/myogen.simulator.SurfaceEMG.html#myogen.simulator.SurfaceEMG.add_noise">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">snr_db</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">noise_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add noise to the surface EMG signal to achieve a specified Signal-to-Noise Ratio (SNR).</span>

<span class="sd">        This function calculates the appropriate noise level based on the signal power and</span>
<span class="sd">        desired SNR, then adds noise to the simulated surface EMG signals. This is useful</span>
<span class="sd">        for studying the effects of measurement noise on EMG analysis algorithms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        snr_db : float</span>
<span class="sd">            Target Signal-to-Noise Ratio in decibels (dB). Higher values mean less noise.</span>
<span class="sd">            Typical values for surface EMG:</span>
<span class="sd">            - High quality: 20-30 dB</span>
<span class="sd">            - Medium quality: 10-20 dB</span>
<span class="sd">            - Low quality: 0-10 dB</span>
<span class="sd">            - Very noisy: &lt; 0 dB</span>

<span class="sd">        noise_type : str, default=&quot;gaussian&quot;</span>
<span class="sd">            Type of noise to add. Currently supports:</span>
<span class="sd">            - &quot;gaussian&quot;: Additive white Gaussian noise (most common for EMG)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        noisy_surface_emg : np.ndarray</span>
<span class="sd">            Surface EMG signals with added noise, same shape as self.surface_emg__tensor.</span>
<span class="sd">            The original signal is preserved in self.surface_emg__tensor.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If surface EMG has not been simulated yet (call simulate_surface_emg first)</span>
<span class="sd">            If noise_type is not supported</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        **SNR Calculation**:</span>
<span class="sd">        SNR_dB = 10 * log10(P_signal / P_noise)</span>

<span class="sd">        Where:</span>
<span class="sd">        - P_signal = mean power of the signal across all channels</span>
<span class="sd">        - P_noise = power of the additive noise</span>

<span class="sd">        The noise power is calculated as:</span>
<span class="sd">        P_noise = P_signal / (10^(SNR_dB/10))</span>

<span class="sd">        **Noise Characteristics**:</span>
<span class="sd">        - Gaussian noise: Zero-mean with variance calculated to achieve target SNR</span>
<span class="sd">        - Noise is added independently to each electrode channel</span>
<span class="sd">        - Noise power is calculated based on the RMS power of the signal</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; # Simulate surface EMG first</span>
<span class="sd">        &gt;&gt;&gt; surface_emg = emg_simulator.simulate_surface_emg(motor_neuron_pool)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Add moderate noise (15 dB SNR)</span>
<span class="sd">        &gt;&gt;&gt; noisy_emg = emg_simulator.add_noise(snr_db=15)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; # Add high noise (5 dB SNR)</span>
<span class="sd">        &gt;&gt;&gt; very_noisy_emg = emg_simulator.add_noise(snr_db=5)</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Original EMG shape: {surface_emg.shape}&quot;)</span>
<span class="sd">        &gt;&gt;&gt; print(f&quot;Noisy EMG shape: {noisy_emg.shape}&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if surface EMG has been simulated</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;surface_emg__tensor&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_emg__tensor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Surface EMG has not been simulated yet. &quot;</span>
                <span class="s2">&quot;Call simulate_surface_emg() first before adding noise.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Validate noise type</span>
        <span class="k">if</span> <span class="n">noise_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;gaussian&quot;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported noise type: </span><span class="si">{</span><span class="n">noise_type</span><span class="si">}</span><span class="s2">. Currently supported: &#39;gaussian&#39;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Calculate signal power (RMS power across all dimensions)</span>
        <span class="n">signal_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_emg__tensor</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># Calculate target noise power from SNR</span>
        <span class="c1"># SNR_dB = 10 * log10(P_signal / P_noise)</span>
        <span class="c1"># Therefore: P_noise = P_signal / (10^(SNR_dB/10))</span>
        <span class="n">snr_linear</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">snr_db</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">noise_power</span> <span class="o">=</span> <span class="n">signal_power</span> <span class="o">/</span> <span class="n">snr_linear</span>

        <span class="c1"># Generate noise with appropriate standard deviation</span>
        <span class="k">if</span> <span class="n">noise_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
            <span class="c1"># For Gaussian noise, variance = power, std = sqrt(power)</span>
            <span class="n">noise_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="p">)</span>

            <span class="c1"># Generate noise with same shape as signal</span>
            <span class="n">noise</span> <span class="o">=</span> <span class="n">RANDOM_GENERATOR</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span>
                <span class="n">loc</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>  <span class="c1"># Zero mean</span>
                <span class="n">scale</span><span class="o">=</span><span class="n">noise_std</span><span class="p">,</span>  <span class="c1"># Standard deviation to achieve target SNR</span>
                <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_emg__tensor</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Add noise to signal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noisy_surface_emg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_emg__tensor</span> <span class="o">+</span> <span class="n">noise</span>

        <span class="c1"># Verify achieved SNR (for validation)</span>
        <span class="n">achieved_signal_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">surface_emg__tensor</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">achieved_noise_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">noise</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">achieved_snr_db</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">achieved_signal_power</span> <span class="o">/</span> <span class="n">achieved_noise_power</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target SNR: </span><span class="si">{</span><span class="n">snr_db</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> dB&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Achieved SNR: </span><span class="si">{</span><span class="n">achieved_snr_db</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> dB&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">noisy_surface_emg</span></div>
</div>



<span class="c1"># For backward compatibility - run simulation if script is executed directly</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">myogen</span><span class="w"> </span><span class="kn">import</span> <span class="n">simulator</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">myogen.utils.plotting.muscle</span><span class="w"> </span><span class="kn">import</span> <span class="n">show_mf_centers</span><span class="p">,</span> <span class="n">show_innervation_areas_2d</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">seaborn</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sns</span>

    <span class="c1"># Generate recruitment thresholds#</span>
    <span class="n">N_MU</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># Number of motor units</span>
    <span class="n">r</span> <span class="o">=</span> <span class="mf">4.9</span>  <span class="c1"># Radius of the muscle in mm</span>
    <span class="n">fiber_density</span> <span class="o">=</span> <span class="mi">400</span>  <span class="c1"># fibers per mm²</span>
    <span class="n">max_innervation_ratio</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span>  <span class="c1"># Maximum innervation area to total muscle area ratio</span>
    <span class="n">grid_resolution</span> <span class="o">=</span> <span class="mi">256</span>  <span class="c1"># Grid resolution for muscle simulation</span>

    <span class="n">recruitment_thresholds</span><span class="p">,</span> <span class="n">recruitment_thresholds_starting_by_zeros</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">simulator</span><span class="o">.</span><span class="n">generate_mu_recruitment_thresholds</span><span class="p">(</span>
            <span class="n">N</span><span class="o">=</span><span class="n">N_MU</span><span class="p">,</span>
            <span class="n">recruitment_range</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>  <span class="c1"># Recruitment range in % MVC</span>
            <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;konstantin&quot;</span><span class="p">,</span>  <span class="c1"># Recruitment pattern model</span>
            <span class="n">konstantin__max_threshold</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">recruitment_thresholds</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="c1"># #Create muscle object</span>
    <span class="c1"># muscle = simulator.Muscle(</span>
    <span class="c1">#     recruitment_thresholds=recruitment_thresholds,</span>
    <span class="c1">#     radius__mm=r,</span>
    <span class="c1">#     fiber_density__fibers_per_mm2=fiber_density,</span>
    <span class="c1">#     max_innervation_area_to_total_muscle_area__ratio=max_innervation_ratio,</span>
    <span class="c1">#     grid_resolution=grid_resolution,</span>
    <span class="c1">#     autorun=True,</span>
    <span class="c1"># )</span>
    <span class="c1"># joblib.dump(muscle, &quot;muscle.pkl&quot;)  # Save for reuse</span>

    <span class="c1"># load muscle object</span>
    <span class="n">muscle</span> <span class="o">=</span> <span class="n">joblib</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s2">&quot;muscle.pkl&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">xkcd</span><span class="p">():</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;font.size&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;axes.titlesize&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;axes.labelsize&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;xtick.labelsize&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;ytick.labelsize&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>
        <span class="n">show_mf_centers</span><span class="p">(</span><span class="n">muscle</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">())</span>

        <span class="n">sns</span><span class="o">.</span><span class="n">despine</span><span class="p">(</span><span class="n">trim</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;font.size&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;axes.titlesize&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;axes.labelsize&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;xtick.labelsize&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="s2">&quot;ytick.labelsize&quot;</span><span class="p">:</span> <span class="mi">24</span><span class="p">})</span>

    <span class="n">selected_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">120</span><span class="p">))))</span>
    <span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">xkcd</span><span class="p">():</span>
        <span class="n">show_innervation_areas_2d</span><span class="p">(</span>
            <span class="n">muscle</span><span class="p">,</span> <span class="n">indices_to_plot</span><span class="o">=</span><span class="n">selected_indices</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Motor Unit Innervation Areas (First 10 MUs)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;X Position (mm)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Y Position (mm)&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="n">surface_emg</span> <span class="o">=</span> <span class="n">SurfaceEMG</span><span class="p">(</span>
        <span class="n">muscle_model</span><span class="o">=</span><span class="n">muscle</span><span class="p">,</span>
        <span class="n">MUs_to_simulate</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="n">MUAP</span> <span class="o">=</span> <span class="n">surface_emg</span><span class="o">.</span><span class="n">simulate_muaps</span><span class="p">(</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_plots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>  <span class="c1"># Center at the muscle belly</span>
    <span class="p">)</span>

    <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="s2">&quot;FDI_MUAPs_multi.npy&quot;</span><span class="p">,</span> <span class="n">MUAP</span><span class="p">)</span>


<span class="c1">#######################################################################################################</span>
<span class="c1">###################################### References #####################################################</span>
<span class="c1">#######################################################################################################</span>

<span class="c1"># BOTELHO, Diego; CURRAN, Kathleen; LOWERY, Madeleine M. Anatomically accurate</span>
<span class="c1"># model of EMG during index finger flexion and abduction derived from diffusion tensor</span>
<span class="c1"># imaging. PLOS Computational Biology, [S. l.], v. 15, n. 8, p. e1007267, 2019. DOI:</span>
<span class="c1"># 10.1371/journal.pcbi.1007267.</span>

<span class="c1"># BRODAR, Vida. Observations on Skin Thickness and Subcutaneous Tissue in Man. Zeitschrift</span>
<span class="c1"># Für Morphologie Und Anthropologie, [S. l.], v. 50, n. 3, p. 386–95, 1960. Available in:</span>
<span class="c1"># https://about.jstor.org/terms</span>

<span class="c1"># ENOKA, Roger M.; FUGLEVAND, Andrew J. Motor unit physiology: Some unresolved issues. Muscle &amp; Nerve,</span>
<span class="c1"># [S. l.], v. 24, n. 1, p. 4–17, 2001. DOI: 10.1002/1097-4598(200101)24:1&lt;4::AID-MUS13&gt;3.0.CO;2-F.</span>

<span class="c1"># FEINSTEIN, Bertram; LINDEGARD, Bengt; NYMAN, Eberhard; WOHLFART, Gunnar.</span>
<span class="c1"># MORPHOLOGIC STUDIES OF MOTOR UNITS IN NORMAL HUMAN MUSCLES. Cells Tissues</span>
<span class="c1"># Organs, [S. l.], v. 23, n. 2, p. 127–142, 1955. DOI: 10.1159/000140989.</span>

<span class="c1"># HWANG, Kun; HUAN, Fan; KIM, Dae Joong. Muscle fibre types of the lumbrical, interossei,</span>
<span class="c1"># flexor, and extensor muscles moving the index finger. Journal of Plastic Surgery and Hand</span>
<span class="c1"># Surgery, [S. l.], v. 47, n. 4, p. 268–272, 2013. DOI: 10.3109/2000656X.2012.755988.</span>

<span class="c1"># JACOBSON, Mark D.; RAAB, Rajnik; FAZELI, Babak M.; ABRAMS, Reid A.; BOTTE, Michael J.;</span>
<span class="c1"># LIEBER, Richard L. Architectural design of the human intrinsic hand muscles. The Journal of</span>
<span class="c1"># Hand Surgery, [S. l.], v. 17, n. 5, p. 804–809, 1992. DOI: 10.1016/0363-5023(92)90446-V.</span>

<span class="c1"># ROELEVELD, K.; BLOK, J. H.; STEGEMAN, D. F.; VAN OOSTEROM, A. Volume conduction</span>
<span class="c1"># models for surface EMG; confrontation with measurements. Journal of Electromyography</span>
<span class="c1"># and Kinesiology, [S. l.], v. 7, n. 4, p. 221–232, 1997. DOI: 10.1016/S1050-6411(97)00009-6.</span>

<span class="c1"># STÖRCHLE, Paul; MÜLLER, Wolfram; SENGEIS, Marietta; LACKNER, Sonja; HOLASEK, Sandra;</span>
<span class="c1"># FÜRHAPTER-RIEGER, Alfred. Measurement of mean subcutaneous fat thickness: eight</span>
<span class="c1"># standardised ultrasound sites compared to 216 randomly selected sites. Scientific Reports,</span>
<span class="c1"># [S. l.], v. 8, n. 1, p. 16268, 2018. DOI: 10.1038/s41598-018-34213-0.</span>
</pre></div>

                </article>
              
              
              
              
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../../../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../../../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025 - 2025, n-squared lab, FAU Erlangen-Nürnberg, Germany.
      <br/>
    
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.2.3.
    <br/>
  </p>
</div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>